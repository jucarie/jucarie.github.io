<!DOCTYPE html>
<html>
<head>
    <title>2D Maze Game with Dynamic Enemies</title>
    <style>
        body {
            background-color: black;
        }
        canvas {
            border: 1px solid black;
        }
        .map {
            position: absolute;
            top: 0;
            left: 0;
        }
        #winModal {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 2px solid black;
            z-index: 1000;
        }
        #modalOverlay {
            display: none;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        .anti_zoom {
            touch-action: manipulation;
        }
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .controls div {
            margin: 5px;
        }
        .controls button {
            width: 60px;
            height: 60px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <canvas id="staticCanvas" class="map"></canvas>
    <canvas id="dynamicCanvas" class="map"></canvas>
    <div id="modalOverlay"></div>
    <div id="winModal">
        <h1>You Won!</h1>
        <button id="closeModal">Close</button>
    </div>

    <div class="controls">
        <div>
            <button id="btnUp" class="anti_zoom">^</button>
        </div>
        <div>
            <button id="btnLeft" class="anti_zoom"><</button>
            <button id="btnDown" class="anti_zoom">_</button>
            <button id="btnRight" class="anti_zoom">></button>
        </div>
    </div>

    <script>
        document.getElementById('btnUp').addEventListener('click', () => moveCharacter(0, -1, images.characterN));
        document.getElementById('btnDown').addEventListener('click', () => moveCharacter(0, 1, images.characterS));
        document.getElementById('btnLeft').addEventListener('click', () => moveCharacter(-1, 0, images.characterW));
        document.getElementById('btnRight').addEventListener('click', () => moveCharacter(1, 0, images.characterE));
    // 34x46
        const TILE_SIZE = 42;
        const maze = [
            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
            [2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2],
            [2, 1, 2, 1, 2, 1, 1, 1, 31, 1, 2],
            [2, 1, 2, 1, 1, 1, 33, 1, 1, 1, 2],
            [2, 4, 2, 2, 1, 2, 1, 2, 1, 1, 2],
            [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
            [2, 1, 1, 1, 30, 1, 1, 1, 1, 1, 2],
            [2, 1, 32, 1, 1, 1, 1, 1, 9, 1, 2],
            [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
        ];
    
        const MAZE_ROWS = maze.length;
        const MAZE_COLS = maze[0].length;
    
        const staticCanvas = document.getElementById('staticCanvas');
        const mazeCtx = staticCanvas.getContext('2d');
        const dynamicCanvas = document.getElementById('dynamicCanvas');
        const dynamicCtx = dynamicCanvas.getContext('2d');
    
        staticCanvas.width = MAZE_COLS * TILE_SIZE;
        staticCanvas.height = MAZE_ROWS * TILE_SIZE;
        dynamicCanvas.width = MAZE_COLS * TILE_SIZE;
        dynamicCanvas.height = MAZE_ROWS * TILE_SIZE;
    
        const images = {
            floor: new Image(),
            wall: new Image(),
            wallCorner: new Image(),
            wallDown: new Image(),
            wallLateral: new Image(),
            turret: new Image(),
            characterN: new Image(),
            characterE: new Image(),
            characterS: new Image(),
            characterW: new Image(),
            end: new Image()
        };
    
        images.floor.src = 'https://jucarie.github.io/img/floor.png';

        images.wall.src = 'https://jucarie.github.io/img/wall.png';
        images.wallCorner.src = 'https://jucarie.github.io/img/wall_corner.png'; // 7
        images.wallDown.src = 'https://jucarie.github.io/img/wall_down.png'; // 6
        images.wallLateral.src = 'https://jucarie.github.io/img/wall_lateral.png'; // 5

        images.characterN.src = 'https://jucarie.github.io/img/character_up.png';
        images.characterE.src = 'https://jucarie.github.io/img/character_right.png';
        images.characterS.src = 'https://jucarie.github.io/img/character_down.png';
        images.characterW.src = 'https://jucarie.github.io/img/character_left.png';

        images.end.src = 'https://jucarie.github.io/img/end.png';
        images.turret.src = 'https://jucarie.github.io/img/turret.png';
    
        let character;
        let characterImage = images.characterS;
        let dynamicElements = [];
    
        function init() {
            generateMaze();
        }
    
        function generateMaze() {
            let imagesLoaded = 0;
            const requiredImages = [
                images.floor, images.wall, images.end,
                images.characterN, images.characterE, images.characterS, images.characterW
            ];
            requiredImages.forEach((image) => {
                image.onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === requiredImages.length) {
                        drawStaticMaze();
                        initDynElementsPosition();
                        drawDynamicLayer();
                    }
                };
                image.onerror = () => {
                    console.error("error loading: " + image.src)
                }
            });
        }
    
        function drawStaticMaze() {
            const mazeImage = document.createElement('canvas');
            mazeImage.width = TILE_SIZE * MAZE_COLS;
            mazeImage.height = TILE_SIZE * MAZE_ROWS;
            const mazeImageCtx = mazeImage.getContext('2d');
    
            const cellImages = {
                1: images.floor,
                2: images.wall,
                4: images.floor,
                5: images.wallLateral,
                6: images.wallDown,
                7: images.wallCorner,
                9: images.end
            };
    
            maze.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cellImages[cell]) {
                        mazeImageCtx.drawImage(cellImages[cell], colIndex * TILE_SIZE, rowIndex * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                });
            });
    
            mazeCtx.drawImage(mazeImage, 0, 0);
        }
    
        function initDynElementsPosition() {
            maze.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cell === 4) {
                        character = { x: colIndex, y: rowIndex };
                    } else if (cell >= 30 && cell <= 33) {
                        const directionMap = {30: 0, 31: 2, 32: 3, 33: 1};
                        dynamicElements.push(createSimpleTurret(colIndex, rowIndex, directionMap[cell]));
                    }
                });
            });
        }
    
        function createSimpleTurret(x, y, direction) {
            return {
                type: 'turret',
                x: x,
                y: y,
                direction: direction,
                
                draw: drawTurret,
                update: updateTurret,
                drawLaserBeam: drawLaserBeam,
                checkCollision: checkTurretCollision
            };
        }
    
        function drawTurret() {
            if (isImageLoaded(images.turret)) {
                dynamicCtx.drawImage(images.turret, this.x * TILE_SIZE, this.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                this.drawLaserBeam();
            } else {
                images.turret.onload = () => {
                    console.log("ReDrawing");
                    drawDynamicLayer();
                };
                images.turret.onerror = () => {
                    console.error("Turret image not found");
                };
            }          
        }
    
        function updateTurret() {
            this.direction = (this.direction + 1) % 4;
        }
    
        function drawLaserBeam() {
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            let [dx, dy] = directions[this.direction];
            let x = this.x;
            let y = this.y;
            dynamicCtx.beginPath();
            dynamicCtx.strokeStyle = 'red';
            dynamicCtx.lineWidth = 2;
    
            let startX = (x + 0.5 + dx * 0.5) * TILE_SIZE;
            let startY = (y + 0.5 + dy * 0.5) * TILE_SIZE;
            dynamicCtx.moveTo(startX, startY);
    
            do {
                x += dx;
                y += dy;
            } while (x >= 0 && x < MAZE_COLS && y >= 0 && y < MAZE_ROWS 
            && maze[y][x] !== 2
            && maze[y][x] !== 5
            && maze[y][x] !== 6
            );
    
            let endX = (x + 0.5 - dx * 0.5) * TILE_SIZE;
            let endY = (y + 0.5 - dy * 0.5) * TILE_SIZE;
            dynamicCtx.lineTo(endX, endY);
    
            dynamicCtx.stroke();
        }
    
        function checkTurretCollision(x, y) {
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            let [dx, dy] = directions[this.direction];
            let beamX = this.x;
            let beamY = this.y;
    
            do {
                beamX += dx;
                beamY += dy;
                if (beamX === x && beamY === y) {
                    return true;
                }
            } while (beamX >= 0 && beamX < MAZE_COLS && beamY >= 0 && beamY < MAZE_ROWS && maze[beamY][beamX] !== 2);
    
            return false;
        }
    
        function isImageLoaded(image) {
            return image.complete && image.naturalHeight !== 0;
        }
    
        function drawDynamicLayer() {
            dynamicCtx.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);   
            dynamicCtx.drawImage(characterImage, character.x * TILE_SIZE, character.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            dynamicElements.forEach(element => element.draw());
        }
    
        function updateTurn() {
            dynamicElements.forEach(element => element.update());
        }
    
        function moveCharacter(dx, dy, newImage) {
            const newX = character.x + dx;
            const newY = character.y + dy;
            if (newX >= 0 && newX < MAZE_COLS && newY >= 0 && newY < MAZE_ROWS && 
                maze[newY][newX] !== 2 && 
                maze[newY][newX] !== 5 && 
                maze[newY][newX] !== 6 && 
                !isTurret(newX, newY)) {
                character.x = newX;
                character.y = newY;
                characterImage = newImage;
                updateTurn();
                drawDynamicLayer();
                if (maze[newY][newX] === 9) {
                    showWinModal();
                } else if (checkCollisions(newX, newY)) {
                    setTimeout(() => { // Important note! This delay is important to draw the drawDynamicLayer()
                        alert("You lose");
                        restartGame();
                    }, 50);
                }
            }
        }
    
        function isTurret(x, y) {
            return dynamicElements.some(element => element.type === 'turret' && element.x === x && element.y === y);
        }
    
        function checkCollisions(x, y) {
            return dynamicElements.some(element => element.checkCollision && element.checkCollision(x, y));
        }
    
        function restartGame() {
            character = undefined;
            characterImage = images.characterS;
            dynamicElements = [];
            dynamicCtx.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
            initDynElementsPosition();
            drawDynamicLayer();
        }
    
        document.addEventListener('keydown', (event) => {
            const moves = {
                'ArrowUp': [0, -1, images.characterN],
                'ArrowDown': [0, 1, images.characterS],
                'ArrowLeft': [-1, 0, images.characterW],
                'ArrowRight': [1, 0, images.characterE]
            };
            if (moves[event.key]) {
                moveCharacter(...moves[event.key]);
            }
        });
    
        function showWinModal() {
            document.getElementById('modalOverlay').style.display = 'block';
            document.getElementById('winModal').style.display = 'block';
        }
    
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('modalOverlay').style.display = 'none';
            document.getElementById('winModal').style.display = 'none';
            restartGame()
        });
    
        init();
    </script>
</body>
</html>